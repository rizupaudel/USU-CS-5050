# -*- coding: utf-8 -*-
"""Copy of Class 09_04 Nim and timing code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MiLzvc9zHuz4QZQ6B6upRsgJwG2oRF0I
"""

import time
import matplotlib.pyplot as plt
import random
from scipy import stats
import numpy as np

## Test function
def test(n):
  ##Declaring an array of n size and shuffling it
  A = [*range(1, n, 1)] 
  random.shuffle(A)
  A.sort()
  # print("My program took", elapsed, "milliseconds to run for ", n, "inputs" )

##Calculates the time taken by each function call and generates graph
def showTime(start, end, interval, function, init = None, fit = 'exponential'):
  #function takes a single integer argument
  #runs the function with an input value starting at start to end by interval
  #generates a graph of run time as a function of problem size
  # init, if provided, is a function that is called once before function is called
  # fit may be 'exponential' then the time as a function of problem size is assumed
  #     to of the form time = c * a^n and the function solves for c and a
  #     where a is the base of the exponential function and c is a multiplicative factor
  # fit my be 'polynomial' then the time as a function of problem size is assumed
  #     to of the form time = c * n ^ b and the function solves for c and b 
  #     where b is the power of n (the degree of the polynomial) and c is a multiplicative factor
    timeLine = []
    end = end + interval
    values = []
    for n in range(start, end, interval):
      start_time = time.time()
      if not init == None:
        init()
      function(n)
      elapsed = (time.time() - start_time)*1000.0
      if elapsed > 0.0:
        timeLine.append(elapsed)
        values.append(n)
    
    nRange = [*range(start,end,interval)]
    
    ##Generating the plot between time taken by each function call with n as variable and n
    plt.plot(nRange, timeLine, 'g')
    plt.xlabel("n")
    if fit == 'exponential':
      plt.yscale('log')
    plt.ylabel("time in milliseconds")
    plt.rcParams["figure.figsize"] = [16,9]
    plt.show()
    if fit == 'exponential': #fit a straight line to n and log time
        slope, intercept, _, _, _ = stats.linregress([values], [np.log(t) for t in timeLine])
        print("time = %.6f %.3f ^ n" % (np.exp(intercept), np.exp(slope)))
    elif fit == 'polynomial': # fit a straight line to log n and log time
        slope, intercept, _, _, _ = stats.linregress([np.log(v) for v in values], [np.log(t) for t in timeLine])
        print("time = %.6f n ^ %.3f" % (np.exp(intercept), slope))

"""Memoizing Nim code and timing code

"""

def win(n):
  # implements NIM game where you can take between 1 and 10 stones off (if available)
  # your turn to move with n stones on the table
  # returns True if the position is a win for you, False if it is a loss
  if n == 0:
    return False
  if n == 1:
    return True
  ans = True
  for i in range(1,min(n+1, 11)):
    ans = ans and win(n-i)
 #   if not ans:
 #     break
  return not ans

    
  #return not ( win(n-1) and win(n-2))

